<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="my thoughts on account abstraction" />

    <title>account abstraction | konrad kopp</title>

    <link rel="stylesheet" href="../styles.css" />
  </head>

  <body>
    <div class="notes-header">
      <ul class="breadcrumb">
        <li><a href="./">notes</a></li>
        <li>account-abstraction</li>
      </ul>
      <p>18.12.23</p>
    </div>
    <div>
      <h1 class="title">account abstraction</h1>
      <h2 class="subtitle text-green" style="margin-bottom: 2rem">
        my take on what account abstraction is and is not
      </h2>
    </div>
    <div>
      <section class="section">
        <h2>what account abstraction is</h2>
        <p>
          Ethereum transactions have two phases: validation and execution.
          Currently, execution is essentially programmable, meaning that anyone
          can specify any arbitrary hex string to be the calldata of a
          transaction which is then sent to the target address and executed.
          However, validation is not programmable. The EVM has a set of rules
          that must be followed in order for a transaction to be valid, such as
          monotonically incrementing nonces, sufficient gas paid by the sender,
          and a valid ECDSA signature using the k1 curve.
        </p>
        <p>
          What account abstraction is, is the idea that the validation phase
          should be equally programmable, meaning that you should be able to
          provide a hex string of arbitrary data that is validated to determine
          whether to execute a transaction or not.
        </p>
      </section>
      <section class="section">
        <h2>what account abstraction is not</h2>
        <p>
          There are many further ideas that fly around, which are almost always
          related to types or features of account abstraction. For example,
          allowing another entity than the sender of a transaction to pay for
          gas, batching multiple transactions into one, having an alternative
          mempool or using the webauthn standard for authentication. Account
          abstraction is not any of these things, but is fundemantally only
          about the goal of programmable validity.
        </p>
      </section>
      <section class="section">
        <h2>types of account abstraction</h2>
        <p>
          There are many ways to achieve this goal, the most often discussed
          ones are native vs non-native and EOA-compatible vs non-EOA-compatible
          account abstraction. Roughly the idea is that native account
          abstraction means protocol-level changes to the EVM, while non-native
          account abstraction is built on top of the existing EVM. An example of
          the former is introducing a new transaction type and an example of the
          latter is using a relayer to broadcast transactions. EOA-compatible
          account abstraction means that the existing EOA accounts can be used,
          while non-EOA-compatible account abstraction means that existing EOAs
          cannot be used.
        </p>
      </section>
      <section class="section">
        <h2>features of account abstraction</h2>
        <p>
          The second dimension on which different account abstraction solutions
          differ depends on the features that they enable. Some examples of
          features are gas-sponsorship, batched transactions, custom nonce rules
          and alternative authentication methods. For example, meta-transactions
          allow for gas-sponsorship and batched transactions, but not for custom
          nonce rules or alternative authentication methods.
        </p>
      </section>
      <section class="section">
        <h2>degrees of account abstraction</h2>
        <p>
          Finally, the fact that the above categories and their subsets can be
          arbitrarily combined means that there are many degrees of account
          abstraction. On one extreme, account abstraction looks exactly like
          how transactions work on Ethereum today, on the other extreme a client
          would be able to send arbitrary hex data to the mempool and have it be
          executed.
        </p>
        <p>
          The existing attempts at account abstraction sit in between these two
          extremes. However, the challenging aspect is that they make different
          tradeoffs, either on type, features or both, making it difficult to
          directly compare them. For example, ERC-4337 allows for
          gas-sponsorship, batched transactions, custom nonce rules and
          alternative authentication methods, but is non-native and
          non-EOA-compatible, meaning that a) EOAs are still required for
          relaying and b) existing EOAs cannot be used as ERC-4337 accounts. By
          contrast, EIP-3074 is EOA-compatible and allows for gas sponsorship,
          custom nonce rules or alternative authentication methods. However,
          EIP-3074 has its own shortcomings, such as the requirement for EOA
          keys to continue being stored and a required consensus change on all
          EVM networks. Without an agreed-upon ranking of the merit of different
          degrees and features, it does not make sense to compare them and claim
          that one is "better" than the other.
        </p>
      </section>
    </div>
  </body>
</html>
